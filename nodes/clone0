#!/usr/bin/env python

import time
import sys
import os

import cv2
import numpy as np
import traitlets as tr

import rospy

import cv_bridge
from sensor_msgs.msg import Image
from sensor_msgs.msg import CompressedImage
from geometry_msgs.msg import Twist

import torch
import torch.nn as nn

import exceed_bot.data as ebdata


class Node(object):
    def __init__(self):
        rospy.init_node('clone0')

        self.model_fname = rospy.get_param("~model_fname")
        self.img_ds_factor = rospy.get_param("~img_ds_factor")
        self.nbins = rospy.get_param("~nbins")
        self.throttle = rospy.get_param("/exceed_bot/target_throttle")
        self.publish_viz = rospy.get_param("/exceed_bot/publish_viz")
        self.steer_scale = rospy.get_param("/exceed_bot/steer_scale")
        self.publish_cmd = rospy.get_param("/exceed_bot/publish_cmd")

        if self.nbins > 0:
            self.bins = np.linspace(-1., 1., self.nbins+1)[1:]

        self.model = None

        self.img_cb = rospy.Subscriber('/camera/color/image_raw', Image, self.img_cb)
        self.bridge = cv_bridge.CvBridge()
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=2)
        self.viz_pub = rospy.Publisher('/viz', Image, queue_size=2)

    def init_model(self):
        if self.model is None:
            rospy.loginfo('loading model %s', self.model_fname)
            self.model = torch.jit.load(self.model_fname)
            self.model = self.model.eval()
            self.model = self.model.cuda()

    def massage_img(self, img):
        h = img.shape[0]
        w = img.shape[1]
        img = cv2.resize(img, (w//self.img_ds_factor, h//self.img_ds_factor), None, 0, 0, cv2.INTER_NEAREST)
        imgpp = ebdata.preprocess(img)
        imgpp = imgpp[None, ...]
        return imgpp

    def img_cb(self, msg):
        #tic = time.time()
        self.init_model()
        buf = np.frombuffer(msg.data, dtype=np.uint8)
        img = buf.reshape((msg.height, msg.width, 3))
        # img = self.bridge.imgmsg_to_cv2(msg)
        imgpp = self.massage_img(img)

        with torch.no_grad():
            imgt = torch.from_numpy(imgpp).cuda()
            yhat = self.model(imgt)
            if self.nbins > 0:
                #yhat = yhat.argmax().cpu().data.numpy()
                yhat = yhat.argmax().item()
                steer = ebdata.undiscretize(yhat, self.bins)
                # BIG HACK
                steer = -steer
            else:
                yhat = yhat.item()
                # BIG HACK
                #steer = yhat
                steer = -yhat
        steer = self.steer_scale * yhat

        rospy.loginfo(steer)
        #toc = time.time()
        #rospy.loginfo('elapsed: %f', (toc - tic)/1000.)
        twist_msg = Twist()
        twist_msg.linear.x = self.throttle
        twist_msg.angular.z = steer
        self.cmd_pub.publish(twist_msg)

        if self.publish_viz:
            self.viz(msg, img, steer)

    def viz(self, msg, img, steer):
        #img_msg = self.bridge.cv2_to_imgmsg(img_np, encoding='bgr8')

        drawimg = img.copy()

        W = img.shape[1]
        H = img.shape[0]
        rectx0 = 20
        rectx1 = W-20
        recty0 = H-40
        recty1 = H-20

        rectxmid = (rectx0 + rectx1)//2

        drawimg = cv2.rectangle(drawimg, (rectx0, recty0), (rectx1, recty1), (0, 255, 0), 3)
        drawimg = cv2.line(drawimg, (rectxmid, recty0), (rectxmid, recty1), (0, 255, 0), 3)

        steer01 = (steer + 1.)/2.
        lx = int(rectx0*steer01 + rectx1*(1-steer01))
        drawimg = cv2.line(drawimg, (lx, recty0), (lx, recty1), (0, 0, 255), 3)

        img_msg = self.bridge.cv2_to_imgmsg(drawimg, encoding='rgb8')
        img_msg.header.stamp = msg.header.stamp
        img_msg.header.frame_id = msg.header.frame_id
        self.viz_pub.publish(img_msg)

    def run(self):
        rate = rospy.Rate(0.1)
        while not rospy.is_shutdown():
            rospy.loginfo('hearbeat')
            rate.sleep()


if __name__ == '__main__':
    node = Node()
    node.run()
