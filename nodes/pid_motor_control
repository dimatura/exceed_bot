#!/usr/bin/env python

"""
tuned for exceed platform
"""

import time
import sys
import os
import struct

import serial
from cobs import cobs
from simple_pid import PID

import rospy

from geometry_msgs.msg import Twist
from std_msgs.msg import Empty
from std_msgs.msg import Float64

import exceed_bot.maestro

MOTOR = 0
SERVO = 5

# won't move until ~1580
# note -- typical minmax values in RC are 988-2012, with 1500 being center
# subs range seems to be 172-1811
# TODO figure out weird reversal/break thing
# note here we use 1/4 pulses
MOTOR_CENTER = 1450*4
MOTOR_MIN = MOTOR_CENTER - 200*4
MOTOR_MAX = MOTOR_CENTER + 180*4

# center between 1330-1500
SERVO_CENTER = 1409
# hard right 990-1113
SERVO_MIN = 1000
# hard left 1660-1880
SERVO_MAX = 1780

# teensy sends data every 50 ms
ENCODER_READ_PERIOD_S = 0.045

class Node(object):
    def __init__(self):
        rospy.init_node('pid_motor_control_node')

        PID_SAMPLE_TIME_S = rospy.get_param('/exceed_bot/pid_sample_time')
        PID_KP = rospy.get_param('/exceed_bot/pid_kp')
        PID_KI = rospy.get_param('/exceed_bot/pid_ki')
        PID_KD = rospy.get_param('/exceed_bot/pid_kd')
        # TPS = ticks per s
        # we use this to scale joystick input for setpoint
        # no min - sadly the quadrature is not working, so we use as tachometer
        #MOTOR_TPS_MAX = 12.
        self.MOTOR_TPS_MAX = rospy.get_param('/exceed_bot/motor_tps_max')

        self.ticks_per_s = 0.
        self.target_ticks_per_s = 0.

        self.pid = PID(Kp=PID_KP, Ki=PID_KI, Kd=PID_KD, setpoint=0., sample_time=PID_SAMPLE_TIME_S, output_limits=(0.0, 1.0))

        # devices
        self.maestro = exceed_bot.maestro.Controller('/dev/maestro')
        self.encoder = serial.Serial('/dev/teensy', 115200, timeout=1.0)
        rospy.on_shutdown(self.shutdown)

        # ros
        self.encoder_timer = rospy.Timer(rospy.Duration(ENCODER_READ_PERIOD_S), self.encoder_cb)
        self.pid_timer = rospy.Timer(rospy.Duration(PID_SAMPLE_TIME_S), self.pid_cb)

        self.pub_motor = rospy.Publisher('/motor_pulse', Float64, queue_size=10)
        self.pub_target_throttle_ticks = rospy.Publisher('/motor_target_ticks', Float64, queue_size=10)
        self.pub_servo = rospy.Publisher('/servo_pulse', Float64, queue_size=10)
        self.pub_encoder = rospy.Publisher('/encoder', Float64, queue_size=10)
        self.sub_vel = rospy.Subscriber('/cmd_vel', Twist, self.cmd_vel_cb)

    def read_encoder(self):
        # reading 8 bytes at 115200 bps should be about 0.5 ms
        # so plenty of time
        # TODO consider just reading this cmd_vel_cb - how frequent are joystick updates?
        # joystick update is ~44-64Hz (0.02-0.015 s)
        # so potentially setpoint changes more frequently than encoder reading
        buf = []
        for _ in range(256):
            b = self.encoder.read()
            if b is None:
                rospy.logerr('encoder read timed out')
                return 0.
            if b == '\0':
                break
            buf.append(b)
        msg_data = cobs.decode(''.join(buf))
        if len(msg_data) != 4:
            rospy.logerr('bad encoder packet length: %d' % len(msg_data))
            return 0.
        msg = struct.unpack('<I', msg_data)
        return float(msg[0])

    def encoder_cb(self, event):
        self.ticks_per_s = self.read_encoder()
        self.pub_encoder.publish(Float64(self.ticks_per_s))

    def pid_cb(self, event):
        # setpoint is updated from cmd_vel_cb
        # self.ticks_per_s is updated from encoder_cb
        # use encoder reading
        throttle_out = self.pid(self.ticks_per_s)
        # map back to pulse
        self.throttle_out_pulse = self.motor_map(throttle_out)
        # NOTE no x4 multiplier here
        self.maestro.setTarget(MOTOR, self.throttle_out_pulse)
        # we send this one too because we don't want to have different threads 
        # manipulating maestro
        self.maestro.setTarget(SERVO, self.steer_pulse*4)

        self.pub_motor.publish(Float64(float(self.throttle_out_pulse)))

    def cmd_vel_cb(self, msg):
        """ from joystick, this runs at 40-60Hz.
        however, will not be so fast in autonomous mode.
        """
        steer = msg.angular.z
        self.steer_pulse = self.servo_map(steer)

        throttle_in = msg.linear.x
        # only using forward in this mode
        throttle_in_ticks = np.clip(throttle_in * self.MOTOR_TPS_MAX, 0.0, self.MOTOR_TPS_MAX)
        # throttle sets a setpoint, in ticks_per_s
        self.pid.setpoint = throttle_in_ticks

        # print info
        rospy.loginfo('steer %f %f', steer, self.steer_pulse)
        rospy.loginfo('throttle in: %f, in_ticks: %f, encoder_ticks: %f, pulse: %f',
                      throttle_in,
                      throttle_in_ticks,
                      self.ticks_per_s,
                      self.throttle_out_pulse)
        self.pub_servo.publish(Float64(float(steer_pulse)))
        self.pub_target_throttle_ticks.publish(Float64(throttle_in_ticks))

    def servo_map(self, val):
        # -1, 1 to 0, 1
        val2 = (val + 1.0)*0.5
        val3 = SERVO_MIN*(1.0-val2) + val2*SERVO_MAX
        val4 = np.clip(val3, SERVO_MIN, SERVO_MAX)
        return int(val4)

    def motor_map(self, val):
        # -1, 1 to 0, 1
        val2 = (val + 1.0)*0.5
        val3 = MOTOR_MIN*(1.-val2) + val2*MOTOR_MAX
        val4 = np.clip(val3, MOTOR_MIN, MOTOR_MAX)
        return int(val4)

    def shutdown(self):
        rospy.loginfo('shutdown')
        self.maestro.stopAll()
        self.maestro.close()
        self.encoder.close()

    def run(self):
        rate = rospy.Rate(0.1)
        while not rospy.is_shutdown():
            rospy.loginfo('hearbeat')
            rate.sleep()


if __name__ == '__main__':
    node = Node()
    node.run()
