#!/usr/bin/env python

import time
import atexit
import struct

import numpy as np
import serial
from cobs import cobs

import rospy
from std_msgs.msg import Float64
from std_msgs.msg import Empty
from geometry_msgs.msg import Twist

MOTOR_MIN = -800
MOTOR_MAX = 800
TURN_DELTA = 200

class Node(object):
    def __init__(self):
        rospy.init_node('zumo_motor')
        self.sub_vel = rospy.Subscriber('/cmd_vel', Twist, self.cmd_vel_cb)
        #self.pub_motor = rospy.Publisher('/motor_pulse', Float64, queue_size=10)

        #zumo_ser = serial.Serial('/dev/ttyACM0', 115200)
        self.zumo_ser = serial.Serial('/dev/zumo', 115200)
        self.zumo_ser.reset_input_buffer()
        self.zumo_ser.reset_output_buffer()
        rospy.loginfo('open: %r' % self.zumo_ser.is_open)
        rospy.on_shutdown(self.shutdown)

    def recv_packet(self):
        s = self.zumo_ser.read_until(b'\x00')
        n = len(s)
        #logging.info('read %d bytes', n)
        if n > 0:
            decoded0 = cobs.decode(s[:(n-1)])
            n_bin = len(decoded0)
            #logging.info('decoded to %d bytes', n_bin)
            decoded1 = struct.unpack('ffffffff', decoded0)
            return decoded1

    def send_packet(self, left_ticks, right_ticks):
        msg0 = struct.pack('ff', left_ticks, right_ticks)
        msg1 = cobs.encode(msg0) + '\x00'
        wrote = self.zumo_ser.write(msg1)

    def cmd_vel_cb(self, msg):
        throttle = msg.linear.x
        steer = msg.angular.z
        throttle_ticks = self.motor_map(throttle)

        #self.pub_servo.publish(Float64(float(steer_pulse)))
        #self.pub_motor.publish(Float64(float(throttle_pulse)))

        rospy.loginfo('throttle %f %f', throttle, throttle_ticks)
        #rospy.loginfo('steer %f %f', steer, steer_pulse)

        delta = steer * TURN_DELTA

        left_ticks = throttle_ticks - delta
        right_ticks = throttle_ticks + delta
        self.send_packet(left_ticks, right_ticks)
        pkt = self.recv_packet()

    def motor_map(self, val):
        # -1, 1 to 0, 1
        val2 = (val + 1.0)/2.
        val3 = MOTOR_MIN*(1.-val2) + val2*MOTOR_MAX
        val4 = np.clip(val3, MOTOR_MIN, MOTOR_MAX)
        return int(val4)

    def shutdown(self):
        rospy.loginfo('shutdown')
        self.zumo_ser.close()

    def run(self):
        rate = rospy.Rate(0.1)
        while not rospy.is_shutdown():
            rospy.loginfo('hearbeat')
            rate.sleep()


if __name__ == '__main__':
    node = Node()
    node.run()
